; Error checking for palindrome
(define (palindrome myFirstList) 							; Define error checking function
  (if (list? myFirstList) 								; Check if entered list is a list
      (find_palindrome myFirstList) 							; If it is, proceed with finding palindrome
      (error "USAGE: (palindrome {LIST})"))) 						; Else, print error

; Error checking for penultimate
(define (penultimate myFirstList)							; Define error checking function
  (if (list? myFirstList)								; Check if entered list is a list
      (find_penultimate myFirstList)							; If it is, proceed with finding penultimate
      (error "USAGE: (penultimate {LIST})")))						; Else, print error

; Error checking for evenrev
(define (evenrev myFirstList)								; Define error checking function
  (if (list? myFirstList)								; Check if entered list is a list
      (find_evenrev myFirstList)							; If it is, proceed with finding evenrev
      (error "USAGE: (evenrev {LIST})")))						; Else, print error

; Error checking for odds
(define (odds myFirstList)								; Define error checking function
  (if (list? myFirstList)								; Check if entered list is a list
      (find_odds myFirstList)								; If it is, proceed with finding odds
      (error "USAGE: (odds {LIST})")))							; Else, print error

; Self made reverse function
(define (rev myFirstList)								; Define reverse function
  (if (null? myFirstList)								; Check if null
      empty										; If null, return empty
      (append (rev (cdr myFirstList)) (cons (car myFirstList) empty)))) 		; Else, take the first element from front of list and add it to the back of a new list

; Function to find odd indicies of list
(define (find_odds myFirstList) 							; Define odds function
  (if (null? myFirstList)								; Check if null
      '()										; If null, return empty list
      (cons (car myFirstList) 								; Else, construct a list of first elements
            (if (null? (cdr myFirstList)) null (find_odds (cdr (cdr myFirstList)))))))	; As long as the end is not null, skip an index and recursively run again

; Function to find even reverse list
(define (find_evenrev myFirstList)							; Define evenrev function
  (cond ((null? myFirstList) '())							; If the list is null, return empty list
        ((null? (cdr myFirstList)) '())							; If the back elements of list are empty, return empty
        (else (append (find_evenrev (cddr myFirstList)) (list (cadr myFirstList))))))	; Else, recursively append the first even element to the back of a new list

; Function to find penultimate
(define (find_penultimate myFirstList)							; Define penultimate function
  (cond ((null? myFirstList) '())							; If the list is null, return empty list
        ((null? (cdr myFirstList)) '())							; If the back elements of list are empty, return empty
        ((equal? (length myFirstList) 2) (cons (car myFirstList)'()))			; If length is 2, construct list using front
        (else (find_penultimate(cdr myFirstList)))))					; Else, recursively construct list using back

; Function to find palindrome, using my reverse function above
(define (find_palindrome myFirstList)							; Define palindrome function
  (cond ((null? myFirstList) 'true)							; If list is null, return true
        ((equal? (rev myFirstList) myFirstList) 'true)					; If the reverse of the list equals the list, return true (uses a RECURSIVE reverse function)
        (else 'false)))									; Else, return false
